#!/usr/bin/bash

# Take a screenshot and put it into "${SCREENSHOTS_DIR}"
# default is to select the area you want to screenshot
# -a or --all to capture the entire screen

readonly SCREENSHOTS_DIR="${HOME}/docs/screenshots"
readonly SAVED_SCREENSHOTS_DIR="${SCREENSHOTS_DIR}/saved"
readonly LAST_SCREENSHOT_FILE="${SCREENSHOTS_DIR}/.last-screenshot"
readonly NUM_SCREENSHOTS=10

###
# Print all given arguments to stderr
###
function echoerr()
{
    cat <<< "$@" 1>&2
}

###
# Read the number from "${LAST_SCREENSHOT_FILE}" to determine which screenshot
# was saved last
###
function last_screenshot()
{
    cat "${LAST_SCREENSHOT_FILE}" 2>/dev/null \
        || echo "0"
}

###
# Write the number from "${LAST_SCREENSHOT_FILE}", but incremented, so that it's
# not over "${NUM_SCREENSHOTS}"
###
function increment_screenshot()
{
    local last="$(last_screenshot)"
    local new=$(((last + 1) % NUM_SCREENSHOTS))
    echo "${new}" >"${LAST_SCREENSHOT_FILE}"
}

###
# Use scrot to take a screenshot (default: select)
# Arguments:    $1 "-a" or "--all" flag, to capture the entire screen
###
function screenshot()
{
    local screenshot_title="$(last_screenshot)"
    local screenshot="${SCREENSHOTS_DIR}/${screenshot_title}.png"

    if [[ "$1" == "-a" ]] || [[ "$1" == "--all" ]]; then
        scrot --overwrite "${screenshot}"
    else
        scrot --overwrite --select --freeze --silent "${screenshot}"
    fi

    xclip -selection clipboard -t image/png -i "${screenshot}" \
        && increment_screenshot
}

###
# Rename a screenshot and put it into "${SAVED_SCREENSHOTS_DIR}", if the user
# confirms that it's the correct photo
# Arguments:    $1 the screenshot number, or `last`
#               $2 the title of the saved screenshot
###
function save()
{
    local num="$1"
    local new_title="$2"


    if [[ "${num}" == "last" ]]; then
        num=$(($(last_screenshot) - 1))
        if [[ "${num}" -lt 0 ]]; then
            num=$(($num + 10))
        fi
    fi

    local screenshot_path="${SCREENSHOTS_DIR}/${num}.png"
    local saved_screenshot_path="${SAVED_SCREENSHOTS_DIR}/${new_title}.png"

    if [[ ! -f "${screenshot_path}" ]]; then
        echoerr "couldn't save screenshot '${num}' - it does not exist"
    elif [[ -z "${new_title}" ]]; then
        echoerr "couldn't save screenshot: invalid (empty) title"
    else
        feh "${screenshot_path}"
        echo "Save this screenshot with title '${new_title}'?"
        select yn in "Yes" "No"; do
            case "${yn}" in
                Yes) cp "${screenshot_path}" "${saved_screenshot_path}" ;;
                No) ;;
            esac
            exit 0
        done
    fi

    exit 1
}

function help()
{
cat <<EOF
Usage: screenshot [-a | --all | help | -h | --help]
       screenshot save <num> <title>

By default, the program stores screenshots in a buffer, 0-indexed, of size 10.
Old screenshots using the same filename are overwritten.

If ran with no arguments, then it will prompt the user to select an area. If ran
with '-a' or '--all' options, the entire screen is captured. In both cases,
the resulting screenshot is copied to clipboard.

If ran with the 'save' command, then you must provide the number of the screenshot
you want to save (0-9) and the title it should be saved under. The photo is
viewed with 'feh' and you are prompted to confirm that it's the correct
screenshot. Note that you can specify "last" as a screenshot number, and it
conveniently finds the last screenshot you took.
EOF
}

function main()
{
    if [[ ! -d "${SCREENSHOTS_DIR}" ]]; then
        mkdir -p "${SCREENSHOTS_DIR}"
        mkdir -p "${SAVED_SCREENSHOTS_DIR}"
        echo "0" >"${LAST_SCREENSHOT_FILE}"
    fi
    if [[ "$1" =~ ("help"|"-h"|"--help") ]]; then
        help
    elif [[ "$1" == "save" ]]; then
        save "$2" "$3"
    else
        screenshot "$1"
    fi
}

main "$@"
